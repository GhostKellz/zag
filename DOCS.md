# Zag Technical Documentation

This document provides technical details about the architecture, design, and internal workings of the Zag package manager.

## Architecture Overview

Zag follows a modular design pattern with clearly separated responsibilities:

```
src/
├── main.zig              # Entry point and command dispatcher
├── root.zig             # Library exports and version information
├── manifest.zig         # build.zig.zon file handling
├── lockfile.zig         # zag.lock file handling
├── downloader.zig       # Package download and hash calculation
└── commands/            # Command implementations
    ├── mod.zig          # Command module exports
    ├── init.zig         # Project initialization
    ├── add.zig          # Adding dependencies
    ├── fetch.zig        # Fetching dependencies
    ├── build.zig        # Building projects
    ├── lock.zig         # Lock file management
    ├── version.zig      # Version display
    └── help.zig         # Help information
```

## File Formats

### build.zig.zon

The `build.zig.zon` file uses Zig's native object notation format to specify project metadata and dependencies:

```zig
.{
    .name = "my-project",
    .version = "0.1.0",
    .dependencies = .{
        .libxev = .{
            .url = "https://github.com/mitchellh/libxev/archive/refs/heads/main.tar.gz",
            .hash = "1220a7b22af9c13f7e054e9b5a7ead0a967a3963715f344676a25c3b744c393354e6",
        },
    },
}
```

### zag.lock

The `zag.lock` file uses JSON format to store exact package versions and metadata for reproducible builds:

```json
// This file is automatically generated by zag.
// Do not edit this file manually.
// Last updated: 1680000000
{
  "packages": [
    {
      "name": "libxev",
      "url": "https://github.com/mitchellh/libxev/archive/refs/heads/main.tar.gz",
      "hash": "1220a7b22af9c13f7e054e9b5a7ead0a967a3963715f344676a25c3b744c393354e6",
      "timestamp": 1680000000
    }
  ]
}
```

## Key Components

### Manifest Parser (ZonFile)

The `ZonFile` struct in `manifest.zig` handles parsing and generating `build.zig.zon` files:

- `init()` - Creates a new empty ZonFile
- `loadFromFile()` - Loads a ZonFile from disk
- `parseFromString()` - Parses a ZonFile from a string
- `addDependency()` - Adds a dependency to the ZonFile
- `saveToFile()` - Saves the ZonFile to disk

### Lock File Manager (LockFile)

The `LockFile` struct in `lockfile.zig` handles managing the `zag.lock` file:

- `init()` - Creates a new empty LockFile
- `loadFromFile()` - Loads or creates a LockFile
- `addPackage()` - Adds or updates a package in the lock file
- `saveToFile()` - Saves the LockFile to disk using JSON
- `getPackage()` - Retrieves package information from the lock file

### Downloader

The `downloader.zig` module handles package downloading and hash calculation:

- `downloadAndHashPackage()` - Downloads a package and calculates its hash
- `resolveGitHubUrl()` - Resolves a GitHub repository to a tarball URL
- `calculateFileHash()` - Calculates the SHA256 hash of a file
- `downloadFile()` - Downloads a file from a URL to the local filesystem

## Command Flow

### Adding a Package

1. User runs `zag add username/repo`
2. Zag checks if `build.zig.zon` exists
3. Zag downloads the package from GitHub
4. Zag calculates the SHA256 hash of the downloaded tarball
5. Zag adds the dependency to `build.zig.zon`
6. Zag updates the `zag.lock` file with the package information

### Fetching Dependencies

1. User runs `zag fetch`
2. Zag reads dependencies from `build.zig.zon`
3. Zag checks if packages exist in the cache
4. Zag compares dependencies with the lock file
5. Zag downloads missing packages and verifies hashes
6. Zag updates the lock file if needed

## Security Considerations

- Package hashes are always verified against the expected hash
- Downloaded files are limited to 100MB by default
- The lock file prevents silent dependency changes
- All network operations use secure HTTPS connections
- GitHub repositories are accessed via HTTPS tarball URLs

## Performance Optimizations

- Packages are cached locally to avoid repeated downloads
- File operations use buffered I/O for better performance
- Memory is managed efficiently using arena allocators
- Hash calculations use streaming to handle large files

## Future Improvements

- Support for custom registry servers
- Semantic versioning and version constraints
- Package signing and verification
- Custom extraction and installation options
- Local package development and linking
- Multiple package sources beyond GitHub
- Integration with Zig's standard build system